import{_ as e,o as s,c as t,d as a}from"./app.92214221.js";const m=JSON.parse('{"title":"websocket","description":"","frontmatter":{},"headers":[],"relativePath":"note/program/network/websoket.md","lastUpdated":1713972511000}'),n={name:"note/program/network/websoket.md"},o=a(`<h1 id="websocket" tabindex="-1">websocket <a class="header-anchor" href="#websocket" aria-hidden="true">#</a></h1><p>当要模拟服务端给客户端推送数据：</p><ol><li>不断去请求后端，查看是否扫码</li><li>长轮询，连接建立后一直保持打开状态，延长连接过期时间，等待服务器返回数据，相比于不断轮询节约资源。</li><li>SSE技术，和websoket类似，但是只能服务端向客户端单向通信。</li></ol><hr><p>为了更好处理以上场景<strong>websoket</strong>被发明了出来： 本质上还是通过http建立连接，然后基于TCP的一个协议。 建立连接的过程：</p><ol><li>发起http请求，要求升级连接：</li></ol><p>状态码变为101</p><div class="language-xml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">connection:upgrade</span></span>
<span class="line"><span style="color:#A6ACCD;">upgrade:websoket</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>收到服务器的相同的响应,建立tcp连接</p><ol><li>开启全双工通信</li></ol><p>soket优化： 1.断线重连策略：在断线重连时，只发送未成功传输的消息，而不是重新发送所有消息。这可以减少重连时的数据传输量。 2.消息压缩：使用消息压缩技术（例如，WebSocket的扩展协议中的消息压缩扩展）来减小消息的大小。这可以显著减少数据传输的带宽消耗，特别是在传输大量文本或数据时。 3.使用WebSocket的二进制帧：WebSocket允许将消息分成多个二进制帧来发送，而不是整个消息一次性发送。这对于大型消息的传输非常有用。</p><p>断开重连：具体来说，我们设置了一个定时器，当连接断开时，会等待一定的时间（例如5秒），然后尝试重新建立连接。如果第一次重连尝试失败，我们会等待更长的时间，以避免频繁的重连请求。我们还限制了最大的重连次数，一旦达到了最大次数，就停止尝试重连并通知用户。此外，我们还监听了WebSocket连接状态的事件，以便在连接关闭时及时触发重连。在尝试重连时，我们还会恢复应用的状态，确保用户不会丢失任何消息或数据。</p>`,12),l=[o];function p(r,c,i,d,_,b){return s(),t("div",null,l)}const h=e(n,[["render",p]]);export{m as __pageData,h as default};
