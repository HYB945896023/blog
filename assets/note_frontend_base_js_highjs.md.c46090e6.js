import{_ as s,o as n,c as a,d as l}from"./app.92214221.js";const u=JSON.parse('{"title":"js 学习","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 函数尾部调用：","slug":"_1-函数尾部调用","link":"#_1-函数尾部调用","children":[{"level":3,"title":"堆栈概念：","slug":"堆栈概念","link":"#堆栈概念","children":[]}]},{"level":2,"title":"2.Object.prototype.toString","slug":"_2-object-prototype-tostring","link":"#_2-object-prototype-tostring","children":[]},{"level":2,"title":"3.Js的运行机制","slug":"_3-js的运行机制","link":"#_3-js的运行机制","children":[]},{"level":2,"title":"3.闭包","slug":"_3-闭包","link":"#_3-闭包","children":[]}],"relativePath":"note/frontend/base/js/highjs.md","lastUpdated":1699523741000}'),p={name:"note/frontend/base/js/highjs.md"},e=l(`<h1 id="js-学习" tabindex="-1">js 学习 <a class="header-anchor" href="#js-学习" aria-hidden="true">#</a></h1><h2 id="_1-函数尾部调用" tabindex="-1">1. 函数尾部调用： <a class="header-anchor" href="#_1-函数尾部调用" aria-hidden="true">#</a></h2><p>  <strong>函数尾部调用</strong>讲的就是一个函数 a 内部调用了 b 函数，那么在 a 函数的调用纪录上就会有一个 b 函数的调用纪录，并且因为调用了 b 函数，所以 a 函数里面的所有变量都会继续被保存，如<strong>A 场景</strong>。<br>   但是如果这个 b 函数在 a 函数尾部调用，那么 a 函数的调用记录就不需要再保存，局部变量也不需要保存，而是用 b 函数的调用记录去替代 a 函数,如<strong>B 场景</strong>。<br>   尾部调用优化的<strong>关键</strong>是确保函数的最后一步操作是一个函数调用，并且将其作为返回值返回，而不会对结果进行任何额外的操作。 所以说在函数需要递归时，最好使用尾部调用来节省内存。</p><ul><li>场景 A:每次递归调用时，需要将当前的数字 n 与前面的总和相加。由于每次递归调用都依赖于前一次递归调用的结果，所以在递归调用之前必须保留前一次调用的调用栈。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 非优化版本</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sum</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">n</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">sum</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>场景 B:不需要保存 n,直接保存在参数里面，这将使得递归函数不再依赖于前一次调用的结果，而是将中间结果作为参数传递给下一次递归调用。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 优化版本（使用函数尾部调用优化）</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">sumTail</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">n</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">total</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">total</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">sumTail</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">total</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="堆栈概念" tabindex="-1">堆栈概念： <a class="header-anchor" href="#堆栈概念" aria-hidden="true">#</a></h3><p>  栈内内存位置发展由高到低，后定义变量的位置 低于 先定义变量的位置。而堆是相反的，分配内存的方式类似于链表，堆中会有个记录空闲空间的链表，每次运行程序前会去遍历这个链表，删除相应的空间，并且记录空间大小。</p><p>  堆中的内存需要手动管理，栈可以直接通过寄存器进行存储，进出栈都有专门的指令，而堆则通过 c/c++提供的库函数与运算符来管理。</p><h2 id="_2-object-prototype-tostring" tabindex="-1">2.Object.prototype.toString <a class="header-anchor" href="#_2-object-prototype-tostring" aria-hidden="true">#</a></h2><p>  通常使用<code>Object.prototype.toString.call(xx)</code>来获取当前对象的类型，其原理是在 JS 中，每个对象都有一个内部属性 [[Class]]，用于表示对象的类型。这个属性通常是通过对象的构造函数来确定的,Object.prototype.toString 方法会将 [[Class]] 属性的值包装在方括号内，生成表示对象类型的字符串。</p><h2 id="_3-js的运行机制" tabindex="-1">3.Js的运行机制 <a class="header-anchor" href="#_3-js的运行机制" aria-hidden="true">#</a></h2><p>js执行过程：</p><ol><li>词法分析</li><li>语法分析</li><li>创建执行上下文</li><li>预编译</li><li>代码执行</li></ol><p>注：AO、VO是过去的概念，ES5+后是词法环境。<br> 预编译创建全局AO、全局VO存储变量提升的变量名与函数标识符， 每个函数被调用时，就会创建自己的AO\\VO。 function声明的才会被整个提升到执行上下文的顶部。</p><h4 id="vo" tabindex="-1">VO: <a class="header-anchor" href="#vo" aria-hidden="true">#</a></h4><p>在 JavaScript 中，变量对象（VO）是执行上下文中的一个内部对象，用于存储变量和函数标识符。在预编译阶段，变量和函数的声明会被处理并存储在变量对象中。 VO就是存储所有变量：全局对象、全局变量、预编译提升的变量与函数声明也存在于此，注意变量的值并不存在这里 是在执行上下文之前被创建。 在预编译阶段，变量对象会被填充以下内容：</p><ol><li><p>函数参数：</p><ul><li>函数参数的名称和对应的值会被存储在变量对象中。</li></ul></li><li><p>函数声明：</p><ul><li>使用函数声明语法（如 <code>function foo() {}</code>）定义的函数会被完整提升到变量对象中。</li></ul></li><li><p>变量声明：</p><ul><li>使用 <code>var</code>、<code>let</code> 或 <code>const</code> 关键字声明的变量会被提升到变量对象中，但是赋值操作不会提升。</li></ul></li></ol><p>需要注意的是，变量对象并非真实存在的对象，它<strong>只是一个抽象的概念</strong>，用于描述变量和函数标识符的存储和访问机制。</p><h4 id="ao" tabindex="-1">AO: <a class="header-anchor" href="#ao" aria-hidden="true">#</a></h4><p>AO变量对象：是VO的一种特殊形式，AO 只在函数执行期间存在，并且在函数执行完毕后被销毁。每次函数被调用时，都会创建一个新的 AO，我们在函数中访问变量、或者其他函数的名称，都是通过AO来访问，</p><p>总结起来，预编译阶段会创建变量对象（全局对象或活动对象），并将变量和函数的声明存储在其中。变量对象提供了变量和函数标识符的访问机制，使得我们在代码执行时可以通过名称来访问它们。</p><h2 id="_3-闭包" tabindex="-1">3.闭包 <a class="header-anchor" href="#_3-闭包" aria-hidden="true">#</a></h2><p>本质：<br>   当函数被定义时，它的词法环境会被保存在闭包中，作为函数的内部状态。当函数执行时，它会在自身的词法环境中查找变量，如果找不到，则会沿着作用域链向上查找，直到找到变量或者到达全局作用域。 这个特性决定了外部不能够访问其内部数据，因为被闭包保护了起来，但是又因为作用域链，内部又可以访问外部的变量。</p><p>   它允许函数内部访问外部作用域中的数据，即使外部作用域已经执行完毕或者无法直接访问。闭包通过保持对外部词法环境的引用，使得函数在后续执行时仍然可以访问和使用外部数据。 <strong>保持对外部词法环境的引用</strong>闭包的核心.</p><h4 id="_1-scopes" tabindex="-1">1. [[Scopes]] <a class="header-anchor" href="#_1-scopes" aria-hidden="true">#</a></h4><p>  当前函数的词法环境会被存在当前函数的[[Scopes]]内 [[Scopes]]是本质是个链表 子[[Scopes]]并不会存父函数的词法环境存进来，而是看本函数使用到父函数中的哪些变量，把这些本函数用到的变量放进去Closure中，最终这个Closure存在本函数的[[Scopes]]中，每个函数被执行前都会创建一个闭包。 每个函数都有一个<code>[[scopes]]</code>，存储的是该函数运行时的作用域链，函数通过预编译确定自己的作用域链。 它就像一个数组，会不断往里面推进新的作用域链，父函数的词法环境创建好后也会被推进子函数的scopes中</p><p>  首先将全局词法环境加完成入栈后就开始创建闭包,接着会去扫描子函数使用到的变量并且加入到<code>closure</code>中，并且为该子函数绑定<code>[[scope]]</code>，使用<code>closure</code>作为<code>[[scoped]]</code>的一部分。 注意点: 所有子函数使用的是同一个<code>closure</code>，并且<code>closure</code>是引用类型，每遇到一个新的子函数使用到新的变量就会把该变量加入到<code>closure</code>，之前被加入到scope的closure也会更新,也就是第一个函数的<code>closure</code>,原本只有a变量，但是随着后续函数被扫描，那么第一个函数的closure里面会新增bc变量.</p><p>  内存泄露: 因为closure是被所有子函数scope引用的，想要闭包消失就必须将所有子函数销毁。 closure会随着变量的改变而更新，原理是c++的指针特性。</p><h4 id="_2-作用域链-是js中用于变量查找的机制" tabindex="-1">2.作用域链：是JS中用于变量查找的机制 <a class="header-anchor" href="#_2-作用域链-是js中用于变量查找的机制" aria-hidden="true">#</a></h4><p>  当在函数内部查找一个变量时，js引擎首先在当前函数的词法环境中查找该变量。如果找不到，它会沿着作用域链向上查找，逐级查找父级作用域的词法环境，直到找到该变量或达到全局作用域。如果在全局作用域中仍然找不到该变量，会抛出 ReferenceError 错误。   函数的 [[Scopes]] 属性包含了一个或多个词法环境，形成了一个作用域链。作用域链描述了函数在执行过程中查找标识符的顺序。当函数在执行时需要访问变量或函数标识符时，它会按照作用域链的顺序逐级向上查找，直到找到匹配的标识符或者到达全局作用域。 例子：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> theThing </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> replaceThing </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">leak</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">theThing</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">unused</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">leak</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">theThing</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    longstr</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">100009</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">someMethod</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> index </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> (index </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">replaceThing</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上图中<code>unused</code>使用了<code>leak</code>变量，产生了闭包，从而所有函数都设置了这个闭包，而又因为 <code>theting</code> 是全局对象不被回收，导致里面的 <code>sommethod</code> 一直存在，相对的整个函数的闭包就会一直存在。<br> 第一次的 theting 是 null，第二次时因为闭包的存在上一次的 thething 被保存了起来，所以第二次的 thething 就是整个对象，以此类推内存里面存储的 thething 越来越大，最终导致了内存泄露</p>`,34),o=[e];function t(c,r,i,F,y,D){return n(),a("div",null,o)}const b=s(p,[["render",t]]);export{u as __pageData,b as default};
