import{_ as s,o as n,c as a,d as l}from"./app.92214221.js";const e="/blog/img/npm.webp.jpg",m=JSON.parse('{"title":"项目知识","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 模块化","slug":"_1-模块化","link":"#_1-模块化","children":[]},{"level":2,"title":"2. Npm run xxx 发生了什么？","slug":"_2-npm-run-xxx-发生了什么","link":"#_2-npm-run-xxx-发生了什么","children":[]},{"level":2,"title":"2.package.json 解析","slug":"_2-package-json-解析","link":"#_2-package-json-解析","children":[{"level":3,"title":"(1) package.lock.json","slug":"_1-package-lock-json","link":"#_1-package-lock-json","children":[]},{"level":3,"title":"(2) npm","slug":"_2-npm","link":"#_2-npm","children":[]}]},{"level":2,"title":"3. Npm link","slug":"_3-npm-link","link":"#_3-npm-link","children":[]}],"relativePath":"note/frontend/interview/project/index.md","lastUpdated":1699610299000}'),o={name:"note/frontend/interview/project/index.md"},p=l(`<h1 id="项目知识" tabindex="-1">项目知识 <a class="header-anchor" href="#项目知识" aria-hidden="true">#</a></h1><h2 id="_1-模块化" tabindex="-1">1. 模块化 <a class="header-anchor" href="#_1-模块化" aria-hidden="true">#</a></h2><p>commonJs 和 Esmodule 是前端常见的模块化方案。<br> commonJs 主要适用于 node 服务端，Esmodule 是浏览器原生支持的。 CommonJS 模块是动态的，意味着模块的导入和导出发生在运行时。ES Modules 是静态的，意味着模块的导入和导出在编译前就确定了。</p><h2 id="_2-npm-run-xxx-发生了什么" tabindex="-1">2. Npm run xxx 发生了什么？ <a class="header-anchor" href="#_2-npm-run-xxx-发生了什么" aria-hidden="true">#</a></h2><p>首先 Npm run xxx 实际上是执行 <code>vue-cli-service serve</code></p><ol><li>问：但是为什么不直接执行 vue-cli-service serve 呢？ <blockquote><p>  因为直接执行会报错，因为程序中并没有这条指令。</p></blockquote></li><li>问：那为什么 npm run xxx 能呢？ <blockquote><p>  这是因为 npm run xxx 时，npm 回去 node_modules 的.bin 目录下找可执行文件，三个文件分别是 node，cmd,powershell 的可行性文件，每个文件头部都写着#!/bin/sh,这说明该文件为可执行的脚本。.bin 目录下的文件表示的是一个个的软链接.</p></blockquote></li><li>问题：那这个软链接是怎么产生的？ <blockquote><p>  首先是 Npm i xxx 的时候，npm 会把 xxx 的软连接配置好，这个软链接实际上就是对文件的一种映射，当程序命令被执行，就会去找.bin 文件下的软链接文件，通过软链接到真正的 npm 包，去执行对应 Js 文件.</p></blockquote></li></ol><h2 id="_2-package-json-解析" tabindex="-1">2.package.json 解析 <a class="header-anchor" href="#_2-package-json-解析" aria-hidden="true">#</a></h2><h3 id="_1-package-lock-json" tabindex="-1">(1) package.lock.json <a class="header-anchor" href="#_1-package-lock-json" aria-hidden="true">#</a></h3><p>使用 npm 安装下的<code>package.lock.json</code>文件:会将所有子依赖扁平化统一安装在首层<code>node_modules</code>，遇到冲突的子依赖，会在该子依赖下创建<code>node_modules</code>并安装冲突的依赖.<br> 在 json 文件中体现为: 某项子依赖中有 dependencies 属性，</p><ul><li>dependencies:依赖的具体安装信息。</li><li>resolved:包具体的安装来源</li><li>integrity:是 hash 值用于验证包有没有变动（更新或失效）</li><li>requires:子依赖对应的子依赖 lock 文件会缓存具体包的下载链接与版本，可以减少很多请求。</li></ul><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">node_modules/element-ui</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">version</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2.13.2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">                  </span><span style="color:#676E95;font-style:italic;">// Element UI 版本号</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">resolved</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">https://registry.xx.tgz</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// Element UI 包的下载地址</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">integrity</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">sha512-r76xxx</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// Element UI 包的完整性校验值</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">dependencies</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// 依赖版本</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">async-validator</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">~1.8.1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">babel-helper-vue-jsx-merge-props</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^2.0.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">deepmerge</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^1.2.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">normalize-wheel</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^1.0.1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">resize-observer-polyfill</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^1.5.0</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">throttle-debounce</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^1.0.1</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">peerDependencies</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">vue</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">^2.5.17</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">// Element UI 对 Vue 的对等依赖版本要求</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_2-npm" tabindex="-1">(2) npm <a class="header-anchor" href="#_2-npm" aria-hidden="true">#</a></h3><h4 id="npm-缓存机制" tabindex="-1">npm 缓存机制 <a class="header-anchor" href="#npm-缓存机制" aria-hidden="true">#</a></h4><p>  npm 下载后，会留一份缓存 <code>npm config get cache</code>可查看，缓存目录有两个文件 <code>content v2</code>/<code>index v5</code>，content 存储 tar 包缓存，index5 则是存 tar 包的 hash 值 ，再次安装依赖包会根据 <strong>integrity、version、name</strong>三个属性生成对应的 key 去比对 index-v5 的 tar 包 hash 值，最终找到 tar 包缓存。<br> 对于缓存的操作 <code>npm cache add /clean/verify</code><br> 验证文件完整性:在安装之前可以获取包的 hash 值，安装完毕后再获取真实 hash 对比两者是否相同。<br> 流程: <img src="`+e+'" alt="npm安装流程图"> 首先检查 npm 的配置文件即<code>.npmrc</code> 文件，顺序是：项目-用户-全局-内置。</p><p>有无 lock 文件，无 lock 文件时就去构建逻辑依赖树，根据依赖树去下载，下载前查看是否有缓存，有就解压到对应位置，没有缓存就去远程下载，并检测包的完整性，下载解压到对应位置，最终生成 lock 文件。</p><p>有 lock 文件，查找 package 与 lock 文件是否冲突，无冲突直接生成逻辑依赖树。再重复以上步骤.</p><h4 id="幽灵链接" tabindex="-1">幽灵链接： <a class="header-anchor" href="#幽灵链接" aria-hidden="true">#</a></h4><p>  pnpm: 解决了幽灵链接问题，<strong>幽灵链接</strong>:没有在<code>dependencies</code>里面定义的包却能引入使用，这是因为所有的依赖都平铺在首层，本质就是误用了子依赖的依赖。</p><p>npm,yarn 缺点: 有多个相同子依赖时，只会提升其中一个，剩余的依然会重复的复制，以及幽灵链接</p><p>pnpm 使用了操作系统中的软硬连接，硬链接: 同一个文件的不同引用，软连接:文件的内容是指向另一个文件。</p><p>虚拟 store 也就是<code>.pnpm</code>文件，真正的包会通过硬链接到虚拟 store，在虚拟 store 里面铺平， 主目录不再是扁平，依赖了哪个包就只存哪个包，子依赖的依赖都是软连接，包与包之间都是软连接，就可以实现复用，不需要复制。</p><p>查找包就通过软连接找包的子依赖，然后根据硬链接找到到真正的包并执行。</p><h2 id="_3-npm-link" tabindex="-1">3. Npm link <a class="header-anchor" href="#_3-npm-link" aria-hidden="true">#</a></h2><p>使用场景:开发一个 npm 模块上传到 Npm 上面,使用再 npm i 进行下载引入使用,但是本地调试包的时候就很不方便,需要一直重新打包发布,这时 npm link 就派上用场.   npm link 的行为其实等同于<code>npm install &#39;包&#39; --global</code>. 脚手架的<code>vue create</code>指令就是被链接到全局，这样子你在任何一个文件新建 powershell 都可以使用该命令去拉取脚手架。   使用后会安装在电脑的全局的 node_module 中，然后在任何一处想要使用则只需要 npm link &#39;那个模块的名称&#39;，类似于将本地的 node_module 当成 Npm 服务器，开发一个包 npm link 上传，使用包 Npm link 包名称安装。</p>',24),t=[p];function r(c,i,D,F,y,d){return n(),a("div",null,t)}const C=s(o,[["render",r]]);export{m as __pageData,C as default};
