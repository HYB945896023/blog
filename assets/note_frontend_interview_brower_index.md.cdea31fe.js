import{_ as l,o as t,c as i,d as r}from"./app.92214221.js";const p=JSON.parse('{"title":"浏览器知识","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器运行原理：","slug":"浏览器运行原理","link":"#浏览器运行原理","children":[{"level":3,"title":"一. 什么是进程？","slug":"一-什么是进程","link":"#一-什么是进程","children":[]},{"level":3,"title":"浏览器进程","slug":"浏览器进程","link":"#浏览器进程","children":[]},{"level":3,"title":"二. 输入url到获取最新网页经历了哪些进程？","slug":"二-输入url到获取最新网页经历了哪些进程","link":"#二-输入url到获取最新网页经历了哪些进程","children":[]},{"level":3,"title":"详解：","slug":"详解","link":"#详解","children":[]}]},{"level":2,"title":"2. 重排与重绘","slug":"_2-重排与重绘","link":"#_2-重排与重绘","children":[]}],"relativePath":"note/frontend/interview/brower/index.md","lastUpdated":1699523741000}'),e={name:"note/frontend/interview/brower/index.md"},o=r('<h1 id="浏览器知识" tabindex="-1">浏览器知识 <a class="header-anchor" href="#浏览器知识" aria-hidden="true">#</a></h1><h2 id="浏览器运行原理" tabindex="-1">浏览器运行原理： <a class="header-anchor" href="#浏览器运行原理" aria-hidden="true">#</a></h2><h3 id="一-什么是进程" tabindex="-1">一. 什么是进程？ <a class="header-anchor" href="#一-什么是进程" aria-hidden="true">#</a></h3><p>启动一个程序时，操作系统就会去创建一个进程且分配内存给这个进程,进程环境里面包含了</p><ol><li>对应分配的内存</li><li>处理任务的线程 一个<code>进程</code>拥有<strong>多个</strong><code>线程</code>,线程可以共享数据，但是一旦有一个线程崩溃将会导致进程的整体崩溃，进程关闭会正确回收内存，但是一旦内存泄漏则进程关闭也不会正常回收内存。 不同进程之间相互访问需要依照IPC协议。</li></ol><h3 id="浏览器进程" tabindex="-1">浏览器进程 <a class="header-anchor" href="#浏览器进程" aria-hidden="true">#</a></h3><p>现代浏览器是多进程，每个页面都有单独的<strong>渲染进程、插件进程</strong>,且页面进程间是相互隔离的,没有访问系统的权限,</p><p>浏览器分为5大进程</p><ol><li>渲染进程：谷歌浏览器使用的是Blink布局引擎，V8js解析引擎（沙箱内运行）。</li><li>插件进程：运行插件，插件进程只运行于一个进程内（沙箱内运行）。</li><li>网络进程：发起网络请求</li><li>GPU进程：绘制网页与UI界面</li><li>浏览器主进程: 以上进程都是主进程的子进程，主进程负责、管理和调配；同时浏览器的整个窗口，包含地址输入栏，书签栏这些东西也都是主进程来控制展示的；</li></ol><h3 id="二-输入url到获取最新网页经历了哪些进程" tabindex="-1">二. 输入url到获取最新网页经历了哪些进程？ <a class="header-anchor" href="#二-输入url到获取最新网页经历了哪些进程" aria-hidden="true">#</a></h3><ol><li>首先输入有效的url,浏览器会自动补充协议以及后缀，后续通过进程通信，<strong>主进程</strong>把URL发送给<strong>网络进程</strong>。</li><li>当<strong>网络进程</strong>接收到http响应头类型为html，就会让<strong>主进程</strong>开启一个<strong>渲染进程</strong>，渲染进程根据请求头初始化后通知<strong>主线程</strong>，主线程会通知渲染进程执行<strong>提交文档</strong>,渲染进程与网络进程建立一个数据通道，将响应体传输给渲染进程，当<strong>渲染进程</strong>接受到文件就会通知主进程，后续将会使<strong>页面白屏</strong>。</li><li><strong>渲染进程</strong>与<strong>GUI进程</strong>开启渲染,渲染完毕后将页面返回给<strong>主进程</strong>进行展示。</li></ol><h3 id="详解" tabindex="-1">详解： <a class="header-anchor" href="#详解" aria-hidden="true">#</a></h3><ol><li>首先<strong>网络进程</strong>会去查看本地缓存（有则中断请求）,若无则发起网络请求，DNS查找解析域名,获取ip地址,然后就是TCP连接发送请求，拿到响应数据。 DNS查找：例子（<a href="http://mail.baidu.com" target="_blank" rel="noreferrer">mail.baidu.com</a>） <ul><li>浏览器缓存</li><li>本地操作系统中的hosts</li><li>本地DNS服务器</li><li>根DNS域名服务器，返回顶级域名（.com、.cn、.org）</li><li>顶级DNS域名（.com、.cn、.org）</li><li>二级域名 （<a href="http://baidu.com" target="_blank" rel="noreferrer">baidu.com</a>）</li><li>三级域名 (<a href="http://mail.baidu.com" target="_blank" rel="noreferrer">mail.baidu.com</a>) 其中从根DNS开始就只会给出下级DNS服务器的地址,递归查询方式。根域名前的操作均在本地完成。</li></ul></li><li>当网络进程拿到响应头则开始解析,为301/2重定向则找Location继续发起新的请求，解析<strong>content-type</strong>进行后续的操作,例如类型为<strong>octet-stream</strong>则会自动开启下载任务,若为<strong>text/html</strong>则会判断是否有同一站点，若有同一站点将会使用同一渲染进程,否则开启不同渲染进程,当渲染进程初始化完毕会去通知主线程，主线程发起<strong>提交文档</strong>任务，渲染与网络进程简历通道，当渲染进程接受完毕后，渲染完毕会向主线程发起<strong>确认提交</strong>，此时页面将出现白屏，渲染进程开始工作。 同一站点：根域名与协议号相同,例子如下: <ul><li><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></li><li><a href="http://wenku.baidu.com" target="_blank" rel="noreferrer">http://wenku.baidu.com</a></li></ul></li><li>渲染流程 <ol><li><p>DOM树的构建：</p><ul><li><strong>html解析器</strong>并不是等待整个文档加载完毕再去解析,它是网络进程加载了多少数据他就会同步解析多少数据，网络进程与html解析器<code>同时运行</code>,通过解析器把开始结束标签转化成token,将token转化为dom节点添加到dom树，这里的转化过程与<a href="./../source/mustache.html">mustache</a>类似，采用栈的形式遇到开始标签压入栈中，遇到结束标签一并弹出</li><li>当遇到<strong>script</strong>标签,考虑到脚本可能会修改dom，就会停止dom解析，直到脚本解析完毕才会继续，当<strong>script</strong>为引入类型，则让网络进程去下载，谷歌浏览器做了预解析的优化，预解析会去查找html中的js/css文件,查找到后先去下载这部分的内容。</li></ul></li><li><p>css树的构建: 所有的样式都会被解析为<strong>styleSheets</strong>,该属性在document上，可以直接打印查看,通过解析获取每个dom的具体样式</p></li><li><p>布局 添加所有可见的节点到布局树中，计算每个节点在页面中的<strong>具体位置</strong></p></li><li><p>分层 分析好层级z-index、滚动3d等属性</p></li><li><p>绘制 绘制由渲染进程中的合成线程执行，合成线程将页面分成很多<code>图块</code>，<code>256*256像素/512*512像素</code>，将视口转化为<strong>位图</strong>,也就是将图块进行<strong>栅格化</strong>处理，栅格化是多线程处理的，会建立一个<strong>栅格化池</strong>来完成，栅格化通常会有GPU进行加速，因为GPU有单独的进程，最终转化为位图并保存至GPU的内存中，全部转化完成通知主线程，绘制位图内容绘制到内存中，最终显示到屏幕上。</p></li></ol></li></ol><h2 id="_2-重排与重绘" tabindex="-1">2. 重排与重绘 <a class="header-anchor" href="#_2-重排与重绘" aria-hidden="true">#</a></h2><ul><li>重排：重新计算dom节点的几何属性（位置属性与大小）</li><li>重绘：将已经知道的所有节点的信息（包括几何信息与具体样式），转化为实际的像素，跳过布局与分层阶段</li><li>浏览器渲染过程：</li></ul><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 ,触发重绘的条件：vidibility、outline、背景色等属性的改变。</li><li>Display:将像素发送给GPU，展示在页面上。</li></ol><ul><li>减少重排重绘？ 措施：</li></ul><ol><li>批量操作dom</li><li>集中样式改变</li><li>使用元素脱离文档流</li><li>开启GPU加速：采用translate改变定位比 绝对定位更高效，其不会触发重排，合成：跳过布局与绘制过程</li></ol>',18),n=[o];function a(s,d,h,c,g,u){return t(),i("div",null,n)}const _=l(e,[["render",a]]);export{p as __pageData,_ as default};
