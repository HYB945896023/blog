import{_ as t,o as e,c as l,d as i}from"./app.92214221.js";const T=JSON.parse('{"title":"http 协议详解","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.http1.1","slug":"_1-http1-1","link":"#_1-http1-1","children":[]},{"level":2,"title":"2. http1.0 与 http1.1 的不同","slug":"_2-http1-0-与-http1-1-的不同","link":"#_2-http1-0-与-http1-1-的不同","children":[]},{"level":2,"title":"3.http2.0","slug":"_3-http2-0","link":"#_3-http2-0","children":[{"level":3,"title":"1.流：","slug":"_1-流","link":"#_1-流","children":[]},{"level":3,"title":"2.多路复用：","slug":"_2-多路复用","link":"#_2-多路复用","children":[]},{"level":3,"title":"3.头部压缩：","slug":"_3-头部压缩","link":"#_3-头部压缩","children":[]},{"level":3,"title":"4.服务端推送：","slug":"_4-服务端推送","link":"#_4-服务端推送","children":[]}]},{"level":2,"title":"3.https","slug":"_3-https","link":"#_3-https","children":[]},{"level":2,"title":"4. http 的缓存策略","slug":"_4-http-的缓存策略","link":"#_4-http-的缓存策略","children":[]}],"relativePath":"note/program/network/http.md","lastUpdated":1689587923000}'),h={name:"note/program/network/http.md"},a=i('<h1 id="http-协议详解" tabindex="-1">http 协议详解 <a class="header-anchor" href="#http-协议详解" aria-hidden="true">#</a></h1><h2 id="_1-http1-1" tabindex="-1">1.http1.1 <a class="header-anchor" href="#_1-http1-1" aria-hidden="true">#</a></h2><ol><li>长连接，默认使用</li><li>请求多发，无需等待响应</li><li>响应分块传输</li><li>多主机-允许一个物理主机有多个域名（给虚拟主机使用） host 域</li><li>加入了缓存控制：Cache-Control、Expires 等字段</li><li>支持断点续传</li></ol><h2 id="_2-http1-0-与-http1-1-的不同" tabindex="-1">2. http1.0 与 http1.1 的不同 <a class="header-anchor" href="#_2-http1-0-与-http1-1-的不同" aria-hidden="true">#</a></h2><ol><li>1.1 增加了长连接，一次连接可以发送多个 http 请求，而 1.0 则需要配置 keep-alive 才可以建立长连接</li><li>增加一些错误码 (409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除)</li><li>增加了缓存相关的 header (Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。)</li><li>增加 HOST 域：1.0 认为一台物理服务器只有一个主机名，而实际上现在一台服务器可开启多个虚拟主机，指向同一个 ip 地址，1.1 增加了 host 域</li><li>支持服务器只传输一部分内容，例如只传送 header，不传 body</li></ol><h2 id="_3-http2-0" tabindex="-1">3.http2.0 <a class="header-anchor" href="#_3-http2-0" aria-hidden="true">#</a></h2><p>核心为：<strong>二进制分帧层</strong>，2.0 采用二进制进行数据传输，1.0 使用的是文本格式。</p><ul><li>流：双向字节流，一个流可以传输多个消息（请求、响应），流是抽象的概念，</li><li>消息：就是一个完整的请求、响应</li><li>帧：通信的最基本单位</li></ul><h3 id="_1-流" tabindex="-1">1.流： <a class="header-anchor" href="#_1-流" aria-hidden="true">#</a></h3><p>一个流可以被看作是一个虚拟的连接 在 HTTP/2 中，一个流可以包含以下情况：</p><ol><li><p>单个请求和单个响应：一个流可以用于发送一个请求，然后接收一个相应。这是最常见的使用情况。</p></li><li><p>多个请求和单个响应：一个流可以发送多个请求，然后接收一个相应。这是通过服务器推送（Server Push）实现的，其中服务器可以主动推送与请求相关的资源。</p></li><li><p>单个请求和多个响应：一个流可以发送一个请求，然后接收多个相应。这是通过多部分（Multiparty）或流式响应（Streaming Response）实现的，其中响应被分段发送。</p></li></ol><h3 id="_2-多路复用" tabindex="-1">2.多路复用： <a class="header-anchor" href="#_2-多路复用" aria-hidden="true">#</a></h3><p>一个 tcp 连接可以同时传输多个流，可以把一个流看作是一个串行连接，串行连接就是需要等上一个请求完成才继续处理下一个请求，也就是要排队。 所以 2.0 中允许多个流的存在， 在 HTTP/2 中，要同时发起多个请求，可以通过创建多个流来实现并发请求的效果。每个流代表一个独立的请求和对应的响应。</p><p>以下是在 HTTP/2 中同时发起两个请求的基本步骤：</p><ol><li><p>建立 HTTP/2 连接：首先，建立一个基于 HTTP/2 的 TCP 连接。可以使用 TLS（HTTPS）或明文的方式建立连接。</p></li><li><p>创建多个流：通过该 TCP 连接，可以创建多个流来同时发起多个请求。每个流都有一个唯一的标识符（Stream Identifier），用于标识该流。</p></li><li><p>发送请求帧：对于每个请求，创建一个请求帧（如 HEADERS Frame 或 PUSH_PROMISE Frame），并将其发送到对应的流上。每个请求帧包含请求的头部信息。</p></li><li><p>接收响应：服务器收到请求后，会在对应的流上发送响应帧（如 HEADERS Frame 或 DATA Frame）。客户端通过该 TCP 连接接收响应帧，根据流标识符来识别响应对应的流。</p></li></ol><p>请求头部帧（HEADERS Frame）可能会放置在一个流中，而请求体数据帧（DATA Frame）可能会放置在另一个流中。</p><h3 id="_3-头部压缩" tabindex="-1">3.头部压缩： <a class="header-anchor" href="#_3-头部压缩" aria-hidden="true">#</a></h3><p>在 1.0 中请求头使用文本格式传输，当请求头不变时，每个请求都带有相同的请求头，这造成了性能上的浪费，2.0 中使用<strong>HPACK</strong>来压缩头部，维护静态、动态字典，静态<strong>Huffman</strong>编码来生成映射，简单来说就是将原本的头部文本变成 <code>1:user-agent</code>这种形式，遇到字典里面没有的，只需要发送首次后保存在字典里面，后续可以全部使用索引代替实际头部文本。</p><h3 id="_4-服务端推送" tabindex="-1">4.服务端推送： <a class="header-anchor" href="#_4-服务端推送" aria-hidden="true">#</a></h3><p>服务端可以主动推送资源到客户端，常用场景：客户端请求了<code>index.html</code>后，服务端可以根据预先定好的规则 <strong>(index.html 依赖于后面两个文件)</strong> 向客户端推送额外的<code>script.js/style.css</code>,加到客户端的缓存当中。 设置<code>&lt;link rel=&quot;preload&quot;&gt;</code>也可以让服务端提前发送资源。</p><h2 id="_3-https" tabindex="-1">3.https <a class="header-anchor" href="#_3-https" aria-hidden="true">#</a></h2><ul><li>http：不加密传输，有很大的安全性问题</li><li>https 默认端口为 443</li><li>https 在 http 基础上增加了 SSL/TSL 协议，负责网络连接的加密， https 建立安全的连接通道，服务端发送一个网站的 ssl 证书信息给客户端 使用非对称与对称加密.</li><li>对称加密：双方都有一套统一的算法进行加密，也就拥有相同的私钥</li><li>非对称加密：核心理念：公钥加密的数据只能使用私钥解密 服务端拥有一个公钥与一个私钥 服务端发送公钥给客户端，客户端使用公钥进行加密，而解密只能由服务端的私钥进行解密。</li></ul><p>https 具体步骤说明：</p><ol><li>客户端发送第一个随机数（TLS 版本、加密套件，随机数 1），服务端保存</li><li>服务端确认客户端发送的信息，发送第二个随机数（TLS 版本、加密套件，随机数 2）</li><li>服务端将 证书 与 公钥 发给客户端，</li><li>客户端生成第三个随机数（预主密钥），将预主密钥使用公钥进行加密，发送到服务端 服务端使用私钥 解密得到预主密钥</li><li>客户端使用 第一随机数+第二随机数 + 预主密钥 = 会话密钥 服务端 第一随机数+第二随机数 + 预主密钥 = 会话密钥</li><li>此时双方使用会话密钥 进行 对称加密通话。</li></ol><h2 id="_4-http-的缓存策略" tabindex="-1">4. http 的缓存策略 <a class="header-anchor" href="#_4-http-的缓存策略" aria-hidden="true">#</a></h2><p>协商缓存:</p><ul><li>last-modified 发送请求查看最后一次请求时间与服务端资源更新时间是否一致,不一致则服务端返回最新资源.</li><li>ETag etag 为资源的唯一标识,发送请求查看该资源的标识与服务端资源当前资源的标识是否一致,不一致则服务端返回最新资源.</li></ul>',27),r=[a];function p(d,n,s,o,c,_){return e(),l("div",null,r)}const f=t(h,[["render",p]]);export{T as __pageData,f as default};
